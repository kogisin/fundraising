package types_test

import (
	"testing"
	time "time"

	"github.com/stretchr/testify/suite"

	"github.com/tendermint/fundraising/x/fundraising/types"
)

type keysTestSuite struct {
	suite.Suite
}

func TestKeysTestSuite(t *testing.T) {
	suite.Run(t, new(keysTestSuite))
}

func (s *keysTestSuite) TestGetAuctionKey() {
	s.Require().Equal([]byte{0x21, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, types.GetAuctionKey(0))
	s.Require().Equal([]byte{0x21, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x9}, types.GetAuctionKey(9))
	s.Require().Equal([]byte{0x21, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xa}, types.GetAuctionKey(10))
}

func (s *keysTestSuite) TestGetBidKey() {
	testCases := []struct {
		auctionID uint64
		sequence  uint64
		expected  []byte
	}{
		{
			uint64(5),
			uint64(10),
			[]byte{0x31, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x5, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xa},
		},
		{
			uint64(2),
			uint64(7),
			[]byte{0x31, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x7},
		},
		{
			uint64(3),
			uint64(5),
			[]byte{0x31, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x5},
		},
	}

	for _, tc := range testCases {
		key := types.GetBidKey(tc.auctionID, tc.sequence)
		s.Require().Equal(tc.expected, key)

		auctionID, sequence := types.ParseGetBidKey(key)
		s.Require().Equal(tc.auctionID, auctionID)
		s.Require().Equal(tc.sequence, sequence)
	}
}

func (s *keysTestSuite) TestVestingQueueKey() {
	testCases := []struct {
		timestamp time.Time
		auctionID uint64
		expected  []byte
	}{
		{
			types.ParseTime("2021-12-01T00:00:00Z"),
			uint64(1),
			[]byte{0x41, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1d, 0x32, 0x30, 0x32,
				0x31, 0x2d, 0x31, 0x32, 0x2d, 0x30, 0x31, 0x54, 0x30, 0x30, 0x3a, 0x30,
				0x30, 0x3a, 0x30, 0x30, 0x2e, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30,
				0x30, 0x30, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1},
		},
		{
			types.ParseTime("2022-01-05T00:00:00Z"),
			uint64(5),
			[]byte{0x41, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1d, 0x32, 0x30, 0x32,
				0x32, 0x2d, 0x30, 0x31, 0x2d, 0x30, 0x35, 0x54, 0x30, 0x30, 0x3a, 0x30,
				0x30, 0x3a, 0x30, 0x30, 0x2e, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30,
				0x30, 0x30, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x5},
		},
		{
			types.ParseTime("2022-07-11T00:00:00Z"),
			uint64(11),
			[]byte{0x41, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1d, 0x32, 0x30, 0x32,
				0x32, 0x2d, 0x30, 0x37, 0x2d, 0x31, 0x31, 0x54, 0x30, 0x30, 0x3a, 0x30,
				0x30, 0x3a, 0x30, 0x30, 0x2e, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30,
				0x30, 0x30, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xb},
		},
	}

	for _, tc := range testCases {
		key := types.GetVestingQueueKey(tc.timestamp, tc.auctionID)
		s.Require().Equal(tc.expected, key)

		timestamp, auctionID, err := types.ParseVestingQueueKey(key)
		s.Require().NoError(err)

		s.Require().Equal(tc.timestamp, timestamp)
		s.Require().Equal(tc.auctionID, auctionID)
	}
}
